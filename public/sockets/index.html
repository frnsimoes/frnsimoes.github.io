<!doctype html>
<html lang="en-US">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="//localhost:1313/images/favicon.png" />
<title>How does the Kernel handle TCP requests? | 
        </title>

        <meta name="referrer" content="no-referrer-when-downgrade" />

        <style>
    :root {
        --font-main: Verdana, sans-serif;
        --heading-color: #222;
        --link-color: #0000ee;
        --visited-color: #551a8b;
        --code-background-color: #f2f2f2;
        --code-color: #222;
    }

    body {
        font-family: "PT Serif", Georgia, Times, "Times New Roman", serif;
        margin: auto;
        margin-top: 15px;
        margin-bottom: 15px;
        padding: 20px;
        max-width: 720px;
        text-align: left;
        background-color: #fff;
        word-wrap: break-word;
        overflow-wrap: break-word;
        line-height: 1.5;
        color: #444;
        box-sizing: border-box;
    }

    h1,
    h3,
    h4,
    h5,
    h6 {
        font-family: var(--font-main);
        color: var(--heading-color);
    }

    h2 {
        font-size: 15px;
    }

    h3 {
        font-size: 14px;
    }

    a {
        color: var(--link-color);
        cursor: pointer;
        text-decoration: none;
    }

    a:hover {
        color: #cc0000;
        text-decoration: none;
    }

    strong,
    b {
        color: var(--heading-color);
    }

    button {
        margin: 0;
        cursor: pointer;
    }

    time {
        font-family: monospace;
        font-style: normal;
        font-size: 15px;
    }

    main {
        line-height: 1.6;
    }

    table {
        width: 100%;
    }

    hr {
        border: 0;
        border-top: 2px dashed #999;
        margin: 20px 0;
    }

    img {
        max-width: 100%;
    }

    pre code {
        color: #222;
        display: block;
        padding: 15px;
        white-space: pre-wrap;
        font-size: 11px;
        overflow-x: auto;
        overflow: auto;
        background-color: #f7f7f7;

        border: #cccccc;
        border-style: solid;
        border-width: 1px;
    }

    code {
        display: inline-block;
        white-space: no-wrap;
        background-color: #f7f7f7;
        font-size: 0.8em;
        line-height: 1.5em;
        border: 1px solid #cccccc;
        padding: 0 2px;
        margin: -1px 0px;
    }

    div.highlight pre {
        background-color: #f2f2f2;
        color: #222;
    }

    div.highlight code {
        background-color: #f2f2f2;
        color: #222;
    }

    footer {
        padding: 25px 0;
        text-align: left;
        border-top: 1px solid #eaeaea;
        margin-top: 40px;
    }

    .title:hover {
        text-decoration: none;
    }

    .title h1 {
        font-size: 1.5em;
    }

    .title {
        text-decoration: none;
    }

    .inline {
        width: auto !important;
    }

    .highlight,
    .code {
        padding: 1px 15px;
        background-color: var(--code-background-color);
        color: var(--code-color);
        border-radius: 3px;
        margin-block-start: 1em;
        margin-block-end: 1em;
        overflow-x: auto;
    }

     
    ul.blog-posts {
        list-style-type: disc;
        padding-left: 20px;
    }

    ul.blog-posts li {
        display: list-item;
        padding: 1px 0;
        margin-bottom: 4px;
    }

    ul.blog-posts li span {
        flex: 0 0 130px;
    }

    ul.blog-posts li a:visited {
        color: var(--visited-color);
    }

    .contact-links {
        font-size: 1.1em;
    }

    .contact-links a {
        color: var(--link-color);
        text-decoration: none;
    }

    <!-- .contact-links a:hover { -->
    <!--     text-decoration: none; -->
    <!-- } -->

    .header-container {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        text-align: left;
        border-bottom: 2px solid #222;
        padding-bottom: 10px;
        margin-bottom: 30px;
    }

    .header-container h1 {
        margin-bottom: 0;
    }
</style>

</head>
    <body>
        <header><div class="header-container">
    <a href="/" class="title"><h1 style="color: #000000;">frn.sh</h1></a>
    <div class="contact-links">
        <a href="/">home</a> /
        
        <a href="/about">about</a> /
        <a href="mailto:frn@frn.sh">email me</a>
        
        
        
    </div>
</div>
</header>
        <main>
<h4 style="text-align: center">How does the Kernel handle TCP requests?</h4>
<content> <p>My first encounter with sockets changed everything. It was one of those &ldquo;aha!&rdquo; moments where the internet&rsquo;s machinery suddenly clicked into place. The internet is a beautiful, beautiful thing. There are so many things to say about how it works - from application protocols, such as HTTP - to sharks biting internet cables in the ocean.</p>
<p>I often ask myself: how the hell did they invent something so cool as communication between processes running on different and distant machines? The design is actually tremendously simple. Let&rsquo;s find out.</p>
<p><img src="/static/sockets/computer-communication-question.jpg" alt="alt"></p>
<p>When a request is received by the machine, the Kernel asks itself: &ldquo;Hey, do I have a socket file descriptor opened on port 80? Let me check&rdquo;. Then it checks a special table for internet connections: a socket table. We can actually see what&rsquo;s going on there:</p>
<pre tabindex="0"><code>cat /proc/net/tcp
➜  ~ cat /proc/net/tcp
  sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode
   4: DE01A8C0:0016 7401A8C0:DE24 01 00000000:00000000 02:0006FC06 00000000     0        0 1030697 2 0000000062dd485f 20 4 31 7 7
   5: DE01A8C0:0016 7401A8C0:DE21 01 00000000:00000000 02:0006F94E 00000000     0        0 1030660 2 000000005ddb2235 20 7 31 9 7
</code></pre><p>We don&rsquo;t need to specify the process ID in <code>/proc/net/tcp</code> because whether we specify it or not the output will be the same: a list of all tcp connections available in that namespace. It contains both listening and connected sockets, and gives us reference to remote and local addresses (<code>local_address</code> and <code>rem_address</code>).</p>
<p>After the kernel checks the socket table, it has access to the file descriptor table, in which it tries to find which process that socket is running on. But how does it find the process by identifying the socket? Well, the last information in /proc/net/tcp is the <code>inode</code> number. The kernel then finds the process in /proc/pid/fd.</p>
<p>Are you curious about this? Open a terminal and run a server:</p>
<h2 id="checking-out-proc-stuff">checking out /proc stuff</h2>
<pre tabindex="0"><code>➜  ~ python -m http.server 8080

Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...
</code></pre><p>On another terminal, find the ID of the process that is running the server:</p>
<pre tabindex="0"><code>➜  ~ ps aux | grep &#34;python -m http.server 8080&#34; | grep -v grep

frns      168674  0.2  0.0  27752 19644 pts/1    S+   23:58   0:00 python -m http.server 8080
</code></pre><p>Now we can see what file descriptors this process has!</p>
<pre tabindex="0"><code>➜  ~ ls -l /proc/168674/fd
total 0
lrwx------ 1 frns frns 64 Jan  1 23:59 0 -&gt; /dev/pts/1
lrwx------ 1 frns frns 64 Jan  1 23:59 1 -&gt; /dev/pts/1
lrwx------ 1 frns frns 64 Jan  1 23:59 2 -&gt; /dev/pts/1
lrwx------ 1 frns frns 64 Jan  1 23:59 3 -&gt; &#39;socket:[1200452]&#39;
</code></pre><p>Let&rsquo;s grep /proc/net/tcp to check the correspondence:</p>
<pre tabindex="0"><code>➜  ~ sudo cat /proc/net/tcp | grep 1200452
   2: 00000000:1F90 (...) 200452 1 0000000002730145 100 0 0 10 0
</code></pre><p><img src="/static/sockets/kernel-role-in-tcp-request.jpg" alt="alt"></p>
<p>This could be magic! Hm. But it must be complicated to run a socket by hand, right?</p>
<h2 id="running-a-tcp-socket">running a tcp socket</h2>
<p>It&rsquo;s not complicated at all. Let&rsquo;s use Python to do this, since Python&rsquo;s socket interface is similar to <a href="https://en.wikipedia.org/wiki/Network_socket">TCP socket standard</a>.</p>
<p>First we create a new socket, bind it to an address and port, and start listening to it.</p>
<pre tabindex="0"><code>import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((&#39;localhost&#39;, 8080))
s.listen(1)
</code></pre><p>Then we loop, like all things computer. We call <code>accept</code> to get the connection, and then <code>recv</code> to receive bytes. Let&rsquo;s find out how this works:</p>
<pre tabindex="0"><code>while True:
    conn, addr = s.accept()
    print(f&#34;Connected by {addr}&#34;)
    while True:
        data = conn.recv(1024)
        if not data:
            break
        print(f&#34;Received: {data.decode()}&#34;)
        conn.send(b&#34;Got your message\n&#34;)
    conn.close()
</code></pre><p>First, let&rsquo;s run the process and find out its ID.</p>
<pre tabindex="0"><code>➜  ~ python tcp_socket.py


➜  ~ ps aux | grep &#34;python tcp_socket.py&#34; | grep -v grep

frns      172143  0.0  0.0  15704 10264 pts/1    S+   00:37   0:00 python tcp_socket.py
</code></pre><p>Then we <code>strace</code> it:</p>
<pre tabindex="0"><code>➜  ~ sudo strace  -p 172143

strace: Process 172143 attached
accept4(3,
</code></pre><p><code>accept4(2)</code> &ldquo;(&hellip;) extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected socket, and returns a new file descriptor referring to that socket. The newly created socket is not in the listening state. The original socket sockfd is unaffected by this call&rdquo;[^1].</p>
<p>by this point (without even send a single request!) we already have two sockets on this process! The first socket was created for the handshake. By the time our process called <code>accept4</code>, a new socket was created and returned to the process. What happened is something like this:</p>
<pre tabindex="0"><code>Process: socket() → One listening socket created
Process: bind() + listen() → Socket starts accepting connections
Client: SYN →
Server: ← SYN-ACK     All using the same listening socket
Client: ACK →
Process: accept4() → NOW kernel creates second socket
</code></pre><p>Now let&rsquo;s create a sending socket with <code>netcat</code>:</p>
<pre tabindex="0"><code>➜  ~ nc localhost 8080
</code></pre><p>By this point, our server called two syscalls: 1. <code>getsockname(2)</code> is the system call responsible for returning the current address to which the socket is bounded (in this case, 127.0.0.1:8080). 2. <code>recvfrom(2)</code> is used to receive messages. In our case, we specified that our receiving buffer has 1024 bytes (<code>recv(1024)</code>). This matters because only 1024 will be send at a time.</p>
<p>Let&rsquo;s send something to our server using the netcat terminal:</p>
<pre tabindex="0"><code>➜  ~ nc localhost 8080
Hello from netcat!
</code></pre><p>We immediately get the response:</p>
<pre tabindex="0"><code>Got your message
</code></pre><p>By this point the process called <code>recvfrom</code> with out message, and then <code>sendto</code> with the response body: <code>Got your message\n</code>. After this, the server is &ldquo;stuck&rdquo; in the <code>recvfrom</code> again, waiting for a new request to be processed.</p>
<p>What happens if we send a request with more than 1024 bytes? I will copy some <a href="https://www.folger.edu/explore/shakespeares-works/hamlet/read/">Hamlet</a> to the netcat terminal.</p>
<p>The first scene alone was enough for 56 <code>Got your message</code> responses. Nice!</p>
<h2 id="closing-the-socket">closing the socket</h2>
<p>By the end of our program, we call <code>conn.close()</code>. This calls <code>close(2)</code> syscall, which is responsible for cleaning up everything related to file descriptors. Let&rsquo;s see what man page has to tell us:</p>
<blockquote>
<p>The close() call deletes a descriptor from the per-process object reference table.</p></blockquote>
<p>Phew. I guess this is it. Can we appreciate webservers now?</p>
 </content>
</main>
        <footer></footer>

          
</body>
</html>
