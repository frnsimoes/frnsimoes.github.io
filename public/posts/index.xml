<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>//localhost:51161/posts/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <copyright>Copyright © Fernando Simões.</copyright>
    <lastBuildDate>Fri, 13 Feb 2026 00:00:00 +0000</lastBuildDate>
    <atom:link href="//localhost:51161/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>What happens inside Postgres when IOPS runs out</title>
      <link>//localhost:51161/bio/</link>
      <pubDate>Fri, 13 Feb 2026 00:00:00 +0000</pubDate>
      <guid>//localhost:51161/bio/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;//localhost:51161/iops&#34;&gt;previous post&lt;/a&gt; I wrote about the three cache layers between a SELECT and disk. That post came from a production incident - queries hanging for 35+ minutes, Heroku timeouts, IOPS pinned at 3000. We fixed it. The root cause was bad indexes forcing Postgres to fetch tens of thousands of rows from disk only to discard them. Better indexes, problem solved.&lt;/p&gt;&#xA;&lt;p&gt;During the incident, the system hit 3000 IOPS and stayed there. It didn&amp;rsquo;t recover on its oown. We had to kill connections manually. But why? What was actually happening inside Postgres that made the situation self-sustaining? I had a wrong mental model for days. This post is about fixing that.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cache layers between select and disk</title>
      <link>//localhost:51161/iops/</link>
      <pubDate>Sun, 08 Feb 2026 00:00:00 +0000</pubDate>
      <guid>//localhost:51161/iops/</guid>
      <description>&lt;p&gt;Saturday, 2 AM. We had a Postgres incident earlier that week - Heroku timeouts, queries running for 35+ minutes, IOPS hitting the provisioned limit. I should have been sleeping. Instead I was staring at EXPLAIN ANALYZE output, asking myself a question I couldn&amp;rsquo;t let go: what actually happens when Postgres reads from disk?&lt;/p&gt;&#xA;&lt;p&gt;I knew I needed a better index. But before fixing anything, I wanted to understand what &amp;ldquo;reading from disk&amp;rdquo; actually means. How many layers of caching exist between a &lt;code&gt;SELECT&lt;/code&gt; and the actual storage device? And what happens when they all fail?&lt;/p&gt;</description>
    </item>
    <item>
      <title>What happens when copy-on-write?</title>
      <link>//localhost:51161/cow/</link>
      <pubDate>Sat, 22 Nov 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:51161/cow/</guid>
      <description>&lt;p&gt;Today I took some time to actually find out what was happening to one of our containers. Zenduty kept buzzing me that a certain app was failing because of memory issues. The log:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;WARNING Memory overcommit must be enabled! Without it, a background save or replication may fail under low memory condition.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;Fine. Let&amp;rsquo;s figure out what this actually means.&lt;/p&gt;&#xA;&lt;p&gt;Redis &lt;a href=&#34;https://redis.io/docs/latest/develop/get-started/faq/#background-saving-fails-with-a-fork-error-on-linux&#34;&gt;documentation&lt;/a&gt; is pretty clear about this issue. Here is the important part: the kernel can&amp;rsquo;t predict how many pages will be written during the child&amp;rsquo;s lifetime. In the worst case, all pages might need copying, so it needs to ensure enough memory exists for full duplication.&lt;/p&gt;</description>
    </item>
    <item>
      <title>How packet switching won</title>
      <link>//localhost:51161/packet-switching/</link>
      <pubDate>Thu, 30 Oct 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:51161/packet-switching/</guid>
      <description>&lt;figure&gt;&lt;img src=&#34;//localhost:51161/static/packet-switching/telephone.png&#34;&#xA;    alt=&#34;A very bad attempt to draw a telephone&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;I don&amp;rsquo;t know why, bt since I discovered about circuit switching, I&amp;rsquo;ve been kinda obsessed with what they represented in the history of telecommunications and computer networking. Telecom engineers had to solve a hard problem. In the analog age, carbon microphones converted voice into electrical signals that traveled over copper wires, with amplifiers boosting the signal to maintain quality across distances. In the digital age, the same copper wires remained, but the approach changed: analog signal was sampled at intervals, quantized into bits, and transmited. Both eras needed circuit switching - the strategy to keep two people talking over a dedicated path.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A production incident: zombie sockets</title>
      <link>//localhost:51161/zombie-sockets/</link>
      <pubDate>Tue, 19 Aug 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:51161/zombie-sockets/</guid>
      <description>&lt;figure&gt;&lt;img src=&#34;//localhost:51161/static/zombie-sockets/body-eater.png&#34;&#xA;    alt=&#34;alt&#34;&gt;&lt;figcaption&gt;&#xA;      &lt;p&gt;The Body Eater: the magical creature you call when you need your sockets closed.&lt;/p&gt;&#xA;    &lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;Last month I just had the most fun time with zombie sockets. It was on my second day at this new job as a platform engineer. A developer approached us saying: &amp;ldquo;Look, there must be a problem in the infrastructure. Users are getting 502s. I already checked everything. It&amp;rsquo;s not the code.&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;We weren’t so sure. The service in question processed PDFs and had a pretty funky workflow: download a template from S3, load the PDF into memory, add some stuff, save it, then upload the new version back to S3. Suspicious.&lt;/p&gt;</description>
    </item>
    <item>
      <title>What is a program?</title>
      <link>//localhost:51161/programs/</link>
      <pubDate>Mon, 30 Jun 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:51161/programs/</guid>
      <description>&lt;p&gt;This is &lt;a href=&#34;https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf&#34;&gt;Remzi Arpaci&lt;/a&gt; being a cool teacher:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;The definition of a process, informally, is quite simple: it is a running program.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;The first time I read this I thought: Okay, Remzi, but what the heck is a program? Months go by and I explore filesystems, inodes, syscalls, etc., etc., and still don&amp;rsquo;t truly understand what a program is. &amp;ldquo;A bunch of bytes&amp;rdquo;. &amp;ldquo;Something on disk&amp;rdquo;. I don&amp;rsquo;t know! Don&amp;rsquo;t ask me! It&amp;rsquo;s a thing you run!&lt;/p&gt;</description>
    </item>
    <item>
      <title>Terminal keyboards</title>
      <link>//localhost:51161/tty/</link>
      <pubDate>Sat, 26 Apr 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:51161/tty/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;//localhost:51161/static/tty/dec.png&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;My birthday will be next month, so I bought myself something I wanted for a while: a terminal keyboard. Last year I read this &lt;a href=&#34;https://www.linusakesson.net/programming/tty/&#34;&gt;article&lt;/a&gt; about the history of the terminal, and it fascinated me. Well, I found this DEC-style Televideo terminal keyboard from the 70s or 80s (I can&amp;rsquo;t be sure of the exact date), and took advantage of the opportunity to learn a few things.&lt;/p&gt;&#xA;&lt;p&gt;These old terminal keyboards were sold alongside a &amp;ldquo;computer terminal.&amp;rdquo; A computer terminal was essentially a &amp;ldquo;dumb&amp;rdquo; display and input device. The real computing power was in the mainframe, which was typically placed in another room in the office building. The terminal would send characters to the mainframe and then display the results back to the user. It didn&amp;rsquo;t have its own operating system. The notion of keycodes, scancodes, and other abstractions that we have nowadays didn&amp;rsquo;t exist in the same way.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Taking a look at runtime/proc.go</title>
      <link>//localhost:51161/go-scheduler/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:51161/go-scheduler/</guid>
      <description>&lt;p&gt;Concurrency and scheduling are hard topics. There are a few resources if you want to understand more about it. The OS implementation is a hard thing to understand, at least if you want to go deep into the details&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Go&amp;rsquo;s scheduler is an abstraction over the OS scheduler. So Go scheduler has its own rules, and, at the same time, makes use of POSIX threads. The scheduler can rapidly become a rabbit hole. So I thought about writing the few things I understood about it to at least paint a big picture of what&amp;rsquo;s happening behind the scenes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Shell internals: builtins and source</title>
      <link>//localhost:51161/shell-source/</link>
      <pubDate>Thu, 22 Aug 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:51161/shell-source/</guid>
      <description>&lt;p&gt;There are many aspects of how the shell works that seem magical to me, particularly when it comes to variables, loading things into memory, forking processes, executing commands, and so on. For example, understanding how the shell manages environment variables and modifies the current session’s state requires understanding concepts like process groups, session ids, and memory space. I will dedicate this lazy sunday afternoon to explore more about the shell.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Line buffering, tty and write(2)</title>
      <link>//localhost:51161/print-strace/</link>
      <pubDate>Mon, 20 May 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:51161/print-strace/</guid>
      <description>&lt;p&gt;A few months back I encountered an interesting behavior while debugging a legacy Flask API running on Docker: since I had no time to setup a proper debugger, I began to add print statements to the backend code (don&amp;rsquo;t judge me, I bet you are lazy too). The problem was: the print output was inconsistent: I tried to reload the React frontend once, and nothing appeared. Then I reload again. Nothing. A few more times, and suddenly the text was output in a single block.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
