<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>//localhost:1313/posts/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <copyright>Copyright © Fernando Simões.</copyright>
    <lastBuildDate>Thu, 30 Oct 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="//localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Beep boop nostalgia</title>
      <link>//localhost:1313/posts/packet-switching/</link>
      <pubDate>Thu, 30 Oct 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/packet-switching/</guid>
      <description>&lt;figure&gt;&lt;img src=&#34;//localhost:1313/static/packet-switching/telephone.png&#34;&#xA;    alt=&#34;A very bad attempt to draw a telephone&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;I&amp;rsquo;ve been reading about telephone history, fascinated by circuit switching - not just the technology, but also what it represents. Circuit switching survived for over a century, and the transition to packet switching wasn&amp;rsquo;t only technological, but shaped by economics, politics, and military needs.&lt;/p&gt;&#xA;&lt;p&gt;Telecom engineers had to solve a hard problem. In the analog age, carbon microphones converted voice into electrical signals that traveled over copper wires. Amplifiers boosted the signal to maintain quality across distances. That was a hell of a thing. In the digital age, the same copper wires remained, but the approach changed: sample the analog signal at intervals, quantize it into bits, transmit those bits. Different encoding, same physical medium. Both eras needed circuit switching - the strategy to keep two people talking over a dedicated path.&lt;/p&gt;</description>
    </item>
    <item>
      <title>What is a program?</title>
      <link>//localhost:1313/posts/programs/</link>
      <pubDate>Sat, 30 Aug 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/programs/</guid>
      <description>&lt;p&gt;This is &lt;a href=&#34;https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf&#34;&gt;Remzi Arpaci&lt;/a&gt; being a cool teacher:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;The definition of a process, informally, is quite simple: it is a running program.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;The first time I read this I thought: Okay, Remzi, but what the heck is a program? Months go by and I explore filesystems, inodes, syscalls, etc., etc., and still don&amp;rsquo;t truly understand what a program is. &amp;ldquo;A bunch of bytes&amp;rdquo;. &amp;ldquo;Something on disk&amp;rdquo;. I don&amp;rsquo;t know! Don&amp;rsquo;t ask me! It&amp;rsquo;s a thing you run!&lt;/p&gt;</description>
    </item>
    <item>
      <title>A production incident: zombie sockets</title>
      <link>//localhost:1313/posts/zombie-sockets/</link>
      <pubDate>Tue, 19 Aug 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/zombie-sockets/</guid>
      <description>&lt;figure&gt;&lt;img src=&#34;//localhost:1313/static/zombie-sockets/body-eater.png&#34;&#xA;    alt=&#34;alt&#34;&gt;&lt;figcaption&gt;&#xA;      &lt;p&gt;The Body Eater: the magical creature you call when you need your sockets closed.&lt;/p&gt;&#xA;    &lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;Last month I just had the most fun time with zombie sockets. It was on my second day at this new job as a platform engineer. A developer approached us saying: &amp;ldquo;Look, there must be a problem in the infrastructure. Users are getting 502s. I already checked everything. It&amp;rsquo;s not the code.&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;We weren’t so sure. The service in question processed PDFs and had a pretty funky workflow: download a template from S3, load the PDF into memory, add some stuff, save it, then upload the new version back to S3. Suspicious.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Terminal keyboards</title>
      <link>//localhost:1313/posts/tty/</link>
      <pubDate>Sat, 26 Apr 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/tty/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;//localhost:1313/static/tty/dec.png&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;My birthday will be next month, so I bought myself something I wanted for a while: a terminal keyboard. Last year I read this &lt;a href=&#34;https://www.linusakesson.net/programming/tty/&#34;&gt;article&lt;/a&gt; about the history of the terminal, and it fascinated me. Well, I found this DEC-style Televideo terminal keyboard from the 70s or 80s (I can&amp;rsquo;t be sure of the exact date), and took advantage of the opportunity to learn a few things.&lt;/p&gt;&#xA;&lt;p&gt;These old terminal keyboards were sold alongside a &amp;ldquo;computer terminal.&amp;rdquo; A computer terminal was essentially a &amp;ldquo;dumb&amp;rdquo; display and input device. The real computing power was in the mainframe, which was typically placed in another room in the office building. The terminal would send characters to the mainframe and then display the results back to the user. It didn&amp;rsquo;t have its own operating system. The notion of keycodes, scancodes, and other abstractions that we have nowadays didn&amp;rsquo;t exist in the same way.&lt;/p&gt;</description>
    </item>
    <item>
      <title>In defense of rabbit holes</title>
      <link>//localhost:1313/posts/rabbit-hole/</link>
      <pubDate>Sat, 01 Feb 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/rabbit-hole/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been thinking about education for a while now. Some time ago, listening to Remzi&amp;rsquo;s lecture about operating systems, I heard him say something like this to his students: &amp;ldquo;Don&amp;rsquo;t just learn the general aspect of things; learn the details. Having just a notion of a subject is precisely the definition of ignorance.&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;This idea from Remzi got me thinking, and today I want to write about what I&amp;rsquo;ve been reflecting on regarding this matter.&lt;/p&gt;</description>
    </item>
    <item>
      <title>How does the Kernel handle TCP requests?</title>
      <link>//localhost:1313/posts/sockets/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/sockets/</guid>
      <description>&lt;p&gt;My first encounter with sockets changed everything. It was one of those &amp;ldquo;aha!&amp;rdquo; moments where the internet&amp;rsquo;s machinery suddenly clicked into place. The internet is a beautiful, beautiful thing. There are so many things to say about how it works - from application protocols, such as HTTP - to sharks biting internet cables in the ocean.&lt;/p&gt;&#xA;&lt;p&gt;I often ask myself: how the hell did they invent something so cool as communication between processes running on different and distant machines? The design is actually tremendously simple. Let&amp;rsquo;s find out.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Taking a look at Go&#39;s runtime/proc.go</title>
      <link>//localhost:1313/posts/go-scheduler/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/go-scheduler/</guid>
      <description>&lt;p&gt;Concurrency and scheduling are hard topics. There are a few resources if you want to understand more about it. The OS implementation is a hard thing to understand, at least if you want to go deep into the details&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Go&amp;rsquo;s scheduler is an abstraction over the OS scheduler. So Go scheduler has its own rules, and, at the same time, makes use of POSIX threads. The scheduler can rapidly become a rabbit hole. So I thought about writing the few things I understood about it to at least paint a big picture of what&amp;rsquo;s happening behind the scenes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Shell, environment lists, processes and sourcing</title>
      <link>//localhost:1313/posts/shell-source/</link>
      <pubDate>Thu, 22 Aug 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/shell-source/</guid>
      <description>&lt;p&gt;There are many aspects of how the shell works that seem magical to me, particularly when it comes to variables, loading things into memory, forking processes, executing commands, and so on. For example, understanding how the shell manages environment variables and modifies the current session’s state requires understanding concepts like process groups, session ids, and memory space. I will dedicate this lazy sunday afternoon to explore more about the shell.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Forcing fork() to fail</title>
      <link>//localhost:1313/posts/when-fork-fails/</link>
      <pubDate>Sat, 22 Jun 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/when-fork-fails/</guid>
      <description>&lt;p&gt;What if &lt;code&gt;fork()&lt;/code&gt; fails?&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; Well, this is really a problematic issue since you have to handle the return value manually. &lt;code&gt;fork()&lt;/code&gt; has three possible return values: If it&amp;rsquo;s &lt;code&gt;0&lt;/code&gt;, we know we are in the child&amp;rsquo;s realm. If it&amp;rsquo;s a positive integer, this represents the child&amp;rsquo;s &lt;code&gt;pid&lt;/code&gt;, and if it&amp;rsquo;s &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;fork()&lt;/code&gt; has failed.&lt;/p&gt;&#xA;&lt;p&gt;But what happens when: you forget to test &lt;code&gt;pid&lt;/code&gt; equals &lt;code&gt;-1&lt;/code&gt; and you want to send a sigkill to the child&amp;rsquo;s &lt;code&gt;pid&lt;/code&gt; in the parent&amp;rsquo;s process? I was reading &lt;a href=&#34;https://rachelbythebay.com/w/2014/08/19/fork/&#34;&gt;rachelbythebay&lt;/a&gt; post on this problem and thought: how could I make &lt;code&gt;fork()&lt;/code&gt; fail? Maybe by allocating lots of memory to the process. Perhaps by using &lt;code&gt;ulimit(3)&lt;/code&gt; to limit the allowed processes? But these felt kind of troublesome, so I found &lt;code&gt;getrlimit&lt;/code&gt;, a system call that limits a resource&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; for the user.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Line buffering, tty and write(2)</title>
      <link>//localhost:1313/posts/print-strace/</link>
      <pubDate>Mon, 20 May 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/print-strace/</guid>
      <description>&lt;p&gt;A few months back I encountered an interesting behavior while debugging a legacy Flask API running on Docker: since I had no time to setup a proper debugger, I began to add print statements to the backend code (don&amp;rsquo;t judge me, I bet you are lazy too). The problem was: the print output was inconsistent: I tried to reload the React frontend once, and nothing appeared. Then I reload again. Nothing. A few more times, and suddenly the text was output in a single block.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
