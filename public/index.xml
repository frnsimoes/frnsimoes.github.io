<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>//localhost:1313/</link>
    <description>Recent content on </description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <copyright>Copyright © Fernando Simões.</copyright>
    <lastBuildDate>Thu, 30 Oct 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="//localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Beep boop nostalgia</title>
      <link>//localhost:1313/posts/packet-switching/</link>
      <pubDate>Thu, 30 Oct 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/packet-switching/</guid>
      <description>&lt;figure&gt;&lt;img src=&#34;//localhost:1313/static/packet-switching/telephone.png&#34;&#xA;    alt=&#34;A very bad attempt to draw a telephone&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;I&amp;rsquo;ve been reading about telephone history, fascinated by circuit switching - not just the technology, but also what it represents. Circuit switching survived for over a century, and the transition to packet switching wasn&amp;rsquo;t only technological, but shaped by economics, politics, and military needs.&lt;/p&gt;&#xA;&lt;p&gt;Telecom engineers had to solve a hard problem. In the analog age, carbon microphones converted voice into electrical signals that traveled over copper wires. Amplifiers boosted the signal to maintain quality across distances. That was a hell of a thing. In the digital age, the same copper wires remained, but the approach changed: sample the analog signal at intervals, quantize it into bits, transmit those bits. Different encoding, same physical medium. Both eras needed circuit switching - the strategy to keep two people talking over a dedicated path.&lt;/p&gt;</description>
    </item>
    <item>
      <title>What is a program?</title>
      <link>//localhost:1313/posts/programs/</link>
      <pubDate>Sat, 30 Aug 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/programs/</guid>
      <description>&lt;p&gt;This is &lt;a href=&#34;https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf&#34;&gt;Remzi Arpaci&lt;/a&gt; being a cool teacher:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;The definition of a process, informally, is quite simple: it is a running program.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;The first time I read this I thought: Okay, Remzi, but what the heck is a program? Months go by and I explore filesystems, inodes, syscalls, etc., etc., and still don&amp;rsquo;t truly understand what a program is. &amp;ldquo;A bunch of bytes&amp;rdquo;. &amp;ldquo;Something on disk&amp;rdquo;. I don&amp;rsquo;t know! Don&amp;rsquo;t ask me! It&amp;rsquo;s a thing you run!&lt;/p&gt;</description>
    </item>
    <item>
      <title>A production incident: zombie sockets</title>
      <link>//localhost:1313/posts/zombie-sockets/</link>
      <pubDate>Tue, 19 Aug 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/zombie-sockets/</guid>
      <description>&lt;figure&gt;&lt;img src=&#34;//localhost:1313/static/zombie-sockets/body-eater.png&#34;&#xA;    alt=&#34;alt&#34;&gt;&lt;figcaption&gt;&#xA;      &lt;p&gt;The Body Eater: the magical creature you call when you need your sockets closed.&lt;/p&gt;&#xA;    &lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;Last month I just had the most fun time with zombie sockets. It was on my second day at this new job as a platform engineer. A developer approached us saying: &amp;ldquo;Look, there must be a problem in the infrastructure. Users are getting 502s. I already checked everything. It&amp;rsquo;s not the code.&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;We weren’t so sure. The service in question processed PDFs and had a pretty funky workflow: download a template from S3, load the PDF into memory, add some stuff, save it, then upload the new version back to S3. Suspicious.&lt;/p&gt;</description>
    </item>
    <item>
      <title>xxd(1) is a neat tool</title>
      <link>//localhost:1313/til/xxd/</link>
      <pubDate>Sun, 25 May 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/til/xxd/</guid>
      <description>&lt;p&gt;Found out about a cool tool today: &lt;code&gt;xxd(1)&lt;/code&gt;. Basically, it can help you convert a hexdump file into binary or vice versa. For example:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;➜   head -c 100 /dev/urandom &amp;gt; out.bin&#xA;➜   cat out.bin&#xA;5O0!3&amp;lt;[N&#xA;                R4DT&amp;#39;{SC95#Rd5b62i^5u(OcD&amp;#34;/MrJBUZ%&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&amp;rsquo;s hexdump it:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;➜  hexdump -C out.bin &amp;gt; out.hex&#xA;➜  cat out.hex&#xA;00000000  35 e2 4f 30 21 b4 33 e2  c8 af b9 3c 5b ba 4e 0b  |5.O0!.3....&amp;lt;[.N.|&#xA;00000010  09 f6 52 16 34 11 44 54  85 96 b6 00 27 a2 7b 04  |..R.4.DT....&amp;#39;.{.|&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And then use xxd(1) to convert it back:&lt;/p&gt;</description>
    </item>
    <item>
      <title>postgres vacuum and netbsd dir size</title>
      <link>//localhost:1313/til/vacuum/</link>
      <pubDate>Fri, 23 May 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/til/vacuum/</guid>
      <description>&lt;p&gt;Running &lt;code&gt;vacuum full&lt;/code&gt; in Postgres requires as much free disk space as your database currently occupies, since it rebuilds the entire table by copying all the non-deleted rows to a new file. &lt;code&gt;vacuum&lt;/code&gt; on the other reclaims dead tuples space. Something &lt;a href=&#34;https://www.youtube.com/watch?v=gY0SE-71LZA&amp;amp;list=PL0qfF8MrJ-jxMfirAdxDs9zIiBg2Wug0z&amp;amp;index=19&#34;&gt;similar&lt;/a&gt; occurs with directories in netBSD. If you create lots of files of 255 chars in a directory, the size of the directory will increase. If you delete all files, the size won&amp;rsquo;t decrease.&lt;/p&gt;</description>
    </item>
    <item>
      <title>writing to disk with O_SYNC</title>
      <link>//localhost:1313/til/osync/</link>
      <pubDate>Sun, 18 May 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/til/osync/</guid>
      <description>&lt;p&gt;write(2) doesn&amp;rsquo;t actually write to disk imediatelly. Instead, it writes to a page cache and the OS periodically handles writes to disk. Using O_SYNC, though, write(2) returns only when it fully wrote the data to a data block.&lt;/p&gt;&#xA;&lt;p&gt;Linux exposes the actual timeframe for periodic writings:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;➜  ~ cat /proc/sys/vm/dirty_writeback_centisecs &#xA;500&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Terminal keyboards</title>
      <link>//localhost:1313/posts/tty/</link>
      <pubDate>Sat, 26 Apr 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/tty/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;//localhost:1313/static/tty/dec.png&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;My birthday will be next month, so I bought myself something I wanted for a while: a terminal keyboard. Last year I read this &lt;a href=&#34;https://www.linusakesson.net/programming/tty/&#34;&gt;article&lt;/a&gt; about the history of the terminal, and it fascinated me. Well, I found this DEC-style Televideo terminal keyboard from the 70s or 80s (I can&amp;rsquo;t be sure of the exact date), and took advantage of the opportunity to learn a few things.&lt;/p&gt;&#xA;&lt;p&gt;These old terminal keyboards were sold alongside a &amp;ldquo;computer terminal.&amp;rdquo; A computer terminal was essentially a &amp;ldquo;dumb&amp;rdquo; display and input device. The real computing power was in the mainframe, which was typically placed in another room in the office building. The terminal would send characters to the mainframe and then display the results back to the user. It didn&amp;rsquo;t have its own operating system. The notion of keycodes, scancodes, and other abstractions that we have nowadays didn&amp;rsquo;t exist in the same way.&lt;/p&gt;</description>
    </item>
    <item>
      <title>In defense of rabbit holes</title>
      <link>//localhost:1313/posts/rabbit-hole/</link>
      <pubDate>Sat, 01 Feb 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/rabbit-hole/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been thinking about education for a while now. Some time ago, listening to Remzi&amp;rsquo;s lecture about operating systems, I heard him say something like this to his students: &amp;ldquo;Don&amp;rsquo;t just learn the general aspect of things; learn the details. Having just a notion of a subject is precisely the definition of ignorance.&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;This idea from Remzi got me thinking, and today I want to write about what I&amp;rsquo;ve been reflecting on regarding this matter.&lt;/p&gt;</description>
    </item>
    <item>
      <title>source and export diff</title>
      <link>//localhost:1313/til/source-and-export/</link>
      <pubDate>Sun, 05 Jan 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/til/source-and-export/</guid>
      <description>&lt;p&gt;Non-interactive shells don&amp;rsquo;t load initialization files, so &lt;code&gt;bash -c &#39;declare -f&#39;&lt;/code&gt; doesn&amp;rsquo;t output anything. But we can source it: &lt;code&gt;bash -c &#39;source ~/.bashrc; hello&#39;&lt;/code&gt;. Or even: &lt;code&gt;bash -c &#39;hello() { echo &amp;quot;hi&amp;quot;; }; declare -f&#39;&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;It&amp;rsquo;s all about memory share in shell modes:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;source&lt;/code&gt; changes only affect current shell memory.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;export&lt;/code&gt; marks variables to be passed to child processes.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Subtile difference that can save us lots of debugging time.&lt;/p&gt;</description>
    </item>
    <item>
      <title>How does the Kernel handle TCP requests?</title>
      <link>//localhost:1313/posts/sockets/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/sockets/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;//localhost:1313/static/sockets/computer-communication-question.jpg&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;When a request is received by the machine, the Kernel asks itself: &amp;ldquo;Hey, do I have a socket file descriptor opened on port 80? Let me check&amp;rdquo;. Then it checks a special table for internet connections: a socket table. We can actually see what&amp;rsquo;s going on there:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cat /proc/net/tcp&#xA;➜  ~ cat /proc/net/tcp&#xA;  sl  local_address rem_address   st tx_queue rx_queue tr tm-&amp;gt;when retrnsmt   uid  timeout inode&#xA;   4: DE01A8C0:0016 7401A8C0:DE24 01 00000000:00000000 02:0006FC06 00000000     0        0 1030697 2 0000000062dd485f 20 4 31 7 7&#xA;   5: DE01A8C0:0016 7401A8C0:DE21 01 00000000:00000000 02:0006F94E 00000000     0        0 1030660 2 000000005ddb2235 20 7 31 9 7&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We don&amp;rsquo;t need to specify the process ID in &lt;code&gt;/proc/net/tcp&lt;/code&gt; because whether we specify it or not the output will be the same: a list of all tcp connections available in that namespace. It contains both listening and connected sockets, and gives us reference to remote and local addresses (&lt;code&gt;local_address&lt;/code&gt; and &lt;code&gt;rem_address&lt;/code&gt;).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Taking a look at Go&#39;s runtime/proc.go</title>
      <link>//localhost:1313/posts/go-scheduler/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/go-scheduler/</guid>
      <description>&lt;p&gt;Concurrency and scheduling are hard topics. There are a few resources if you want to understand more about it. The OS implementation is a hard thing to understand, at least if you want to go deep into the details&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Go&amp;rsquo;s scheduler is an abstraction over the OS scheduler. So Go scheduler has its own rules, and, at the same time, makes use of POSIX threads. The scheduler can rapidly become a rabbit hole. So I thought about writing the few things I understood about it to at least paint a big picture of what&amp;rsquo;s happening behind the scenes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Shell, environment lists, processes and sourcing</title>
      <link>//localhost:1313/posts/shell-source/</link>
      <pubDate>Thu, 22 Aug 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/shell-source/</guid>
      <description>&lt;p&gt;There are many aspects of how the shell works that seem magical to me, particularly when it comes to variables, loading things into memory, forking processes, executing commands, and so on. For example, understanding how the shell manages environment variables and modifies the current session’s state requires understanding concepts like process groups, session ids, and memory space. I will dedicate this lazy sunday afternoon to explore more about the shell.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Forcing fork() to fail</title>
      <link>//localhost:1313/posts/when-fork-fails/</link>
      <pubDate>Sat, 22 Jun 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/when-fork-fails/</guid>
      <description>&lt;p&gt;What if &lt;code&gt;fork()&lt;/code&gt; fails?&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; Well, this is really a problematic issue since you have to handle the return value manually. &lt;code&gt;fork()&lt;/code&gt; has three possible return values: If it&amp;rsquo;s &lt;code&gt;0&lt;/code&gt;, we know we are in the child&amp;rsquo;s realm. If it&amp;rsquo;s a positive integer, this represents the child&amp;rsquo;s &lt;code&gt;pid&lt;/code&gt;, and if it&amp;rsquo;s &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;fork()&lt;/code&gt; has failed.&lt;/p&gt;&#xA;&lt;p&gt;But what happens when: you forget to test &lt;code&gt;pid&lt;/code&gt; equals &lt;code&gt;-1&lt;/code&gt; and you want to send a sigkill to the child&amp;rsquo;s &lt;code&gt;pid&lt;/code&gt; in the parent&amp;rsquo;s process? I was reading &lt;a href=&#34;https://rachelbythebay.com/w/2014/08/19/fork/&#34;&gt;rachelbythebay&lt;/a&gt; post on this problem and thought: how could I make &lt;code&gt;fork()&lt;/code&gt; fail? Maybe by allocating lots of memory to the process. Perhaps by using &lt;code&gt;ulimit(3)&lt;/code&gt; to limit the allowed processes? But these felt kind of troublesome, so I found &lt;code&gt;getrlimit&lt;/code&gt;, a system call that limits a resource&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; for the user.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Line buffering, tty and write(2)</title>
      <link>//localhost:1313/posts/print-strace/</link>
      <pubDate>Mon, 20 May 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/print-strace/</guid>
      <description>&lt;p&gt;A few months back I encountered an interesting behavior while debugging a legacy Flask API running on Docker: since I had no time to setup a proper debugger, I began to add print statements to the backend code (don&amp;rsquo;t judge me, I bet you are lazy too). The problem was: the print output was inconsistent: I tried to reload the React frontend once, and nothing appeared. Then I reload again. Nothing. A few more times, and suddenly the text was output in a single block.&lt;/p&gt;</description>
    </item>
    <item>
      <title>cool trick: the kernel stack of a process</title>
      <link>//localhost:1313/til/proc-pid-stack/</link>
      <pubDate>Mon, 15 Apr 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/til/proc-pid-stack/</guid>
      <description>&lt;p&gt;I found a cool trick to see what&amp;rsquo;s happening to a blocked (&lt;code&gt;sleeping&lt;/code&gt;) process: &lt;code&gt;cat /proc/pid/stack&lt;/code&gt;. Yep, you can peek at the trace of kernel functions related to a process!&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;➜  pexpl git:(main) ✗ ps aux | grep p.py&#xA;frns       23703  0.0  0.0  13888  7948 pts/3    Sl+  02:48   0:00 nvim p.py&#xA;&#xA;➜  pexpl git:(main) ✗ sudo cat /proc/23703/stack&#xA;[&amp;lt;0&amp;gt;] do_epoll_wait+0x698/0x7d0&#xA;[&amp;lt;0&amp;gt;] do_compat_epoll_pwait.part.0+0xb/0x70&#xA;[&amp;lt;0&amp;gt;] __x64_sys_epoll_pwait+0x91/0x140&#xA;[&amp;lt;0&amp;gt;] do_syscall_64+0x55/0xb0&#xA;[&amp;lt;0&amp;gt;] entry_SYSCALL_64_after_hwframe+0x6e/0xd8&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The information I get from this trace is that epoll was called, so the kernel is doing IO multiplexing, probably waiting for a event, and then called a syscall that blocked the process. Combined with other tools, like &lt;code&gt;strace&lt;/code&gt;, &lt;code&gt;&amp;lt;pid&amp;gt;/stack&lt;/code&gt; can give an specific perspective of what&amp;rsquo;s wrong with a process. How cool is that?&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>//localhost:1313/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/about/</guid>
      <description>&lt;h3 id=&#34;about-me&#34;&gt;About me&lt;/h3&gt;&#xA;&lt;p&gt;Hi! I&amp;rsquo;m Fernando, a software engineer who also happens to actually like computers. I grew up in the 90s, fascinated by the magical machine &lt;em&gt;beep&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;p&gt;I like writing about networks, systems, or whatever I&amp;rsquo;m currently obsessed with.&lt;/p&gt;&#xA;&lt;h3 id=&#34;about-this-website&#34;&gt;About this website&lt;/h3&gt;&#xA;&lt;p&gt;This blog is a collection of my notes and casual experiments, but it also serves as an incentive for me to keep writing about the things I love and to procrastinate in a &lt;a href=&#34;https://structuredprocrastination.com/&#34;&gt;structured way&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
